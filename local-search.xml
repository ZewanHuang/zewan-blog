<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Unity Inspector 自定义按钮</title>
    <link href="/2021/08/11/unity/editor-inspector/"/>
    <url>/2021/08/11/unity/editor-inspector/</url>
    
    <content type="html"><![CDATA[<p>在开发 Unity 项目时，为了有更快更方便的工作流，我们通常会在 Editor 下开发一些方便实用的工具。在工具中，最常用的就是自定义按钮。通过按钮，我们在不启动项目的情况下就能运行指定代码块。</p><p>此处以点击按钮生成立方块 Cube 的功能为例。</p><h2 id="点击按钮生成-Cube"><a href="#点击按钮生成-Cube" class="headerlink" title="点击按钮生成 Cube"></a>点击按钮生成 Cube</h2><p>在 Unity Inspector 创建自定义按钮，需要用到 Editor 和 MonoBehaviour 的继承类。</p><p>你可以按照我这样的项目框架来创建代码文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">Assets<br>└─Scripts<br>    └─InspectorButton<br>        ├──Editor<br>        │   └─CubeGeneratorEditor.cs<br>        └─CubeGenerator.cs<br></code></pre></td></tr></table></figure><p>我们只需要编写两个代码文件 <code>CubeGeneratorEditor.cs</code> 和 <code>CubeGenerator.cs</code></p><h3 id="MonoBehaviour-Script"><a href="#MonoBehaviour-Script" class="headerlink" title="MonoBehaviour Script"></a>MonoBehaviour Script</h3><p>继承 MonoBehaviour 的类，可作为 Component 挂载在 Unity 对象上。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">InspectorButton</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CubeGenerator</span> : <span class="hljs-title">MonoBehaviour</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> Vector3 CubePosition;<br><br>        <span class="hljs-comment">// 此处定义按钮函数供 Editor 按钮调用</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildCube</span>(<span class="hljs-params"></span>) <span class="hljs-comment">// 该函数创建 Cube 对象并将其加入挂载物体的子对象中</span></span><br>        &#123;<br>            GameObject cube = GameObject.CreatePrimitive(PrimitiveType.Cube);<br>            cube.transform.position = CubePosition;<br>            cube.transform.rotation = Quaternion.identity;<br>            <br>            cube.transform.SetParent(transform);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DeleteAllCubes</span>(<span class="hljs-params"></span>) <span class="hljs-comment">// 该函数删除挂载物体的所有子对象</span></span><br>        &#123;<br>            <span class="hljs-built_in">int</span> childCount = transform.childCount;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; childCount ; i++) &#123;<br>                DestroyImmediate(transform.GetChild (<span class="hljs-number">0</span>).gameObject);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Editor-Script"><a href="#Editor-Script" class="headerlink" title="Editor Script"></a>Editor Script</h3><p><strong>继承 Editor 的类，必须放在 Editor 文件夹下。</strong>我们在该类中定义 Inspector 按钮，并调用上面代码定义的函数。</p><p>因为我声明了命名空间 <code>InspectorButton.Editor</code>，因此必须指明该类继承于 <code>UnityEditor.Editor</code>。当然，声明命名空间并不必要，不声明时继承略写为 <code>Editor</code> 即可。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEditor;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">InspectorButton.Editor</span><br>&#123;<br>    [<span class="hljs-meta">CustomEditor(typeof(CubeGenerator))</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CubeGeneratorEditor</span> : <span class="hljs-title">UnityEditor.Editor</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnInspectorGUI</span>(<span class="hljs-params"></span>)</span><br>        &#123;<br>            DrawDefaultInspector(); <span class="hljs-comment">// 默认 Inspector 样式</span><br>            CubeGenerator script = (CubeGenerator) target;<br><br>            <span class="hljs-comment">// 此处定义按钮调用 CubeGenerator 的函数</span><br>            <span class="hljs-keyword">if</span> (GUILayout.Button(<span class="hljs-string">&quot;Generate Cube&quot;</span>))<br>            &#123;<br>                script.BuildCube();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (GUILayout.Button(<span class="hljs-string">&quot;Delete All Cubes&quot;</span>))<br>            &#123;<br>                script.DeleteAllCubes();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="创建对象挂载脚本"><a href="#创建对象挂载脚本" class="headerlink" title="创建对象挂载脚本"></a>创建对象挂载脚本</h3><p>在 Unity 中创建一个名为 <code>Cubes</code> 的空对象，点击 <code>Add Component</code> 挂载 <code>CubeGenerator</code> 脚本。</p><p>填入 <code>Cube Position</code>，点击 <code>Generate Cube</code> 即可生成 Cube 对象，点击 <code>Delete All Cubes</code> 即可删除前面生成的所有 Cube 对象。</p><p><img src="/img/articles/21-8-12/01.png"></p><h2 id="点击按钮创建人物角色"><a href="#点击按钮创建人物角色" class="headerlink" title="点击按钮创建人物角色"></a>点击按钮创建人物角色</h2><p>上面使用生成 Cube 对象的例子，介绍了创建 Inspector 自定义按钮的方法。</p><p>我还在 Invector 第三方角色控制器的基础上，编写了简易的角色创建按钮 (Character Creator) 和活动角色管理按钮 (Active Charater Manager)，可供参考。</p><p>相关 Unitypackage 链接为 <a href="https://github.com/ZewanHuang/unitypackages/tree/master/ThirdController_adapted_from_Invector_on_creator">github.com/ZewanHuang/unitypackages</a></p><blockquote><p>我会在该仓库中更新实用插件的 Unity Packages，欢迎 Star ~</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>Inspector</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>资源信息库</title>
    <link href="/2021/07/22/notes/materials/"/>
    <url>/2021/07/22/notes/materials/</url>
    
    <content type="html"><![CDATA[<h2 id="Research"><a href="#Research" class="headerlink" title="Research"></a>Research</h2><ul><li><a href="/sources/RE00-How-to-Write-a-SIGGRAPH-Paper.pdf">How to write a SIGGRAPH paper</a>：SIGGRAPH Course 教你怎么写 SIGGRAPH 论文</li><li><a href="/sources/RE01-How-to-do-research.pdf">How to do research</a>：MIT 教授 Bill Freeman 告诉你如何做研究</li><li><a href="/sources/RE02-Elements-of-a-successful-graduate-career.pdf">Elements of a successful graduate career</a>：MIT 教授 Bill Freeman 找众多教授收集的成功秘诀</li><li><a href="/sources/RE03-Notes-on-writing.pdf">Notes on writing</a>：MIT 教授 Fredo Durand 的写论文秘诀</li><li><a href="/sources/RE04-Graduate-student-survival-guide.pdf">Graduate student survival guide</a>：Waterloo 大学教授撰写的研究生生存指南</li></ul><h2 id="UX-AR"><a href="#UX-AR" class="headerlink" title="UX/AR"></a>UX/AR</h2><ul><li><a href="https://www.zhihu.com/question/474370179/answer/2040838303">AR 了解与入门 - 知乎问题</a></li><li><a href="https://zhuanlan.zhihu.com/c_1236335814964682752">隐形的界面：万物互联时代的交互设计 - 知乎专栏</a></li></ul><h3 id="系统教程"><a href="#系统教程" class="headerlink" title="系统教程"></a>系统教程</h3><ul><li><a href="https://blog.csdn.net/yolon3000/category_9023477.html">ARFoundation 之路 - DavidWang</a></li><li><a href="https://blog.csdn.net/yolon3000/category_9283315.html">ARCore 之路 - DavidWang</a></li><li><a href="https://blog.csdn.net/yolon3000/category_10141425.html">ARKit 之路 - DavidWang</a></li><li><a href="https://blog.csdn.net/yolon3000/category_10976435.html">HoloLens2 之路 - DavidWang</a></li></ul><h2 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h2><h3 id="Unity-Animator"><a href="#Unity-Animator" class="headerlink" title="Unity/Animator"></a>Unity/Animator</h3><ul><li><a href="https://blog.csdn.net/qq_28849871/article/details/72593569">Unity/Animation – 创建Animation Clip</a></li><li><a href="http://blog.csdn.net/qq_28849871/article/details/72771779">Unity/Animation – 调节Animation Curves</a></li><li><a href="http://blog.csdn.net/qq_28849871/article/details/72821633">Unity/Animation – 添加动画事件(Animation Events)</a></li><li><a href="https://blog.csdn.net/qq_28849871/article/details/77914922">Unity/Animation – 创建Animator Controller</a></li></ul><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><h3 id="系统学习"><a href="#系统学习" class="headerlink" title="系统学习"></a>系统学习</h3><ul><li><a href="http://www.ai-start.com/ml2014/">斯坦福大学吴恩达2014机器学习教程中文笔记目录 - 黄海广博士译</a></li><li><a href="https://www.coursera.org/learn/machine-learning">机器学习 Coursera 网课 - Andrew Ng 吴恩达</a></li></ul><h2 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h2><h3 id="系统学习-1"><a href="#系统学习-1" class="headerlink" title="系统学习"></a>系统学习</h3><ul><li><a href="https://www.coursera.org/specializations/deep-learning">深度学习专项课程 Coursera 网课 - Andrew Ng 吴恩达</a></li></ul><h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3><ul><li><a href="https://www.zhihu.com/column/c_145288300">直观梳理深度学习 - 大佬专栏</a></li><li><a href="https://zhuanlan.zhihu.com/p/31561570">深度学习基础(基本概念、优化算法、初始化、正则化等)</a></li><li><a href="https://zhuanlan.zhihu.com/p/31727402">计算机视觉四大基本任务(分类、定位、检测、分割)</a></li><li><a href="https://zhuanlan.zhihu.com/p/31727405">计算机视觉其他应用(网络压缩、视觉问答、可视化、风格迁移等)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵求导</title>
    <link href="/2021/07/18/math/matrix-derivation/"/>
    <url>/2021/07/18/math/matrix-derivation/</url>
    
    <content type="html"><![CDATA[<p>本篇主要介绍向量、矩阵求导的定义，包含向量、矩阵、标量之间的求导，并给出一些常用的方法和恒等式。</p><h2 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明"></a>符号说明</h2><table><thead><tr><th align="center">符号</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">$\mathbf{A},\mathbf{X},\mathbf{Y}$</td><td align="center"><strong>矩阵</strong></td></tr><tr><td align="center">$\mathbf{a},\mathbf{x},\mathbf{y}$</td><td align="center"><strong>向量</strong></td></tr><tr><td align="center">$a,x,y$</td><td align="center"><strong>标量</strong></td></tr><tr><td align="center">$X^{T}$</td><td align="center">矩阵 $X$ 的转置</td></tr><tr><td align="center">$tr(X)$</td><td align="center">矩阵 $X$ 的迹</td></tr><tr><td align="center">$det(X)$ 或 $|X|$</td><td align="center">矩阵 $X$ 的行列式</td></tr><tr><td align="center">$||X||$</td><td align="center">矩阵 $X$ 的范数</td></tr></tbody></table><h2 id="矩阵向量求导定义"><a href="#矩阵向量求导定义" class="headerlink" title="矩阵向量求导定义"></a>矩阵向量求导定义</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>在高等数学中，我们学过标量对标量的求导，比如标量 $y$ 对标量 $x$ 的求导，可表示为 $\frac{\partial y}{\partial x}$。</p><p>有时我们会有一组标量 $y_{i},i=1,2,…$，对标量 $x$ 求导，我们会得到一组结果：</p><p>$$<br>\frac{\partial y_{i}}{\partial x},i=1,2,…<br>$$</p><p>如果将该组标量 $y_{i}$ 组成向量 $\mathbf{y}$，我们得到的计算结果也会是一个向量 $\frac{\partial \mathbf{y}}{\partial x}$。</p><p>向量对标量的求导，正是<strong>将向量的每个分量分别对标量求导</strong>，最后组成一个向量的形式。</p><p>根据求导的自变量和因变量的类型，属于标量、向量或矩阵，我们有 9 种可能的矩阵求导定义：</p><table><thead><tr><th align="center">自变量\因变量</th><th align="center">标量 $y$</th><th align="center">向量 $\mathbf{y}$</th><th align="center">矩阵 $\mathbf{Y}$</th></tr></thead><tbody><tr><td align="center">标量 $x$</td><td align="center">$\frac{\partial y}{\partial x}$</td><td align="center">$\frac{\partial \mathbf{y}}{\partial x}$</td><td align="center">$\frac{\partial \mathbf{Y}}{\partial x}$</td></tr><tr><td align="center">向量 $\mathbf{x}$</td><td align="center">$\frac{\partial y}{\partial \mathbf{x}}$</td><td align="center">$\frac{\partial \mathbf{y}}{\partial \mathbf{x}}$</td><td align="center">$\frac{\partial \mathbf{Y}}{\partial \mathbf{x}}$</td></tr><tr><td align="center">矩阵 $\mathbf{X}$</td><td align="center">$\frac{\partial y}{\partial \mathbf{X}}$</td><td align="center">$\frac{\partial \mathbf{y}}{\partial \mathbf{X}}$</td><td align="center">$\frac{\partial \mathbf{Y}}{\partial \mathbf{X}}$</td></tr></tbody></table><p>事实上，矩阵、向量、标量之间的求导，是将因变量各个元素分别对自变量各个元素进行求导。比如向量 $\mathbf{y}$ 对向量 $\mathbf{x}$ 求导，则分别将  $\mathbf{y}$ 的每个分量对 $\mathbf{x}$ 的每个分量求导。</p><p>但这样自然会出现一个排列次序的问题。我们将两个长度为 $m,n$ 的向量的分量对应求导，得到 $m\times n$ 个标量。为简练表示结果，我们需要将其写成矩阵的形式，这样就涉及到这 $m\times n$ 个值如何排列。</p><p>为解决这个问题，需要引入<strong>求导布局</strong>的概念。</p><h3 id="求导布局"><a href="#求导布局" class="headerlink" title="求导布局"></a>求导布局</h3><p>为解决矩阵向量求导的结果不唯一，我们引入求导布局。最基本的求导布局有两个：分子布局 (numerator layout) 和分母布局 (denominator layout)。</p><p>对于<strong>分子布局</strong>而言，求导结果的维度以分子为主。也就是说，如果向量 $\mathbf{y}$ 是一个 $m$ 维的<u>列向量</u>，它对标量 $x$ 的求导结果 $\frac{\partial \mathbf{y}}{\partial x}$ 也是一个 $m$ 维<u>列向量</u>；若 $\mathbf{y}$ 是一个 $m$ 维的<u>行向量</u>，则求导结果也是一个 $m$ 维的<u>行向量</u>。</p><p>对于<strong>分母布局</strong>而言，求导结果的维度以分母为主。也就是说，如果向量 $\mathbf{y}$ 是一个 $m$ 维的<u>列向量</u>，它对标量 $x$ 的求导结果 $\frac{\partial \mathbf{y}}{\partial x}$ 是一个 $m$ 维<u>行向量</u>；若 $\mathbf{y}$ 是一个 $m$ 维的<u>行向量</u>，则求导结果也是一个 $m$ 维的<u>列向量</u>。</p><p>可以看出，分子布局和分母布局相差一个转置。</p><p>稍微麻烦些的是向量对向量的求导。比如 $m$ 维列向量 $\mathbf{y}$ 对 $n$ 维列向量 $\mathbf{x}$ 求导，如果是分子布局，结果为：</p><p>$$<br>\frac{\partial \mathbf{y}}{\partial \mathbf{x}}<br>=<br>\left(<br>\begin{matrix}<br>\frac{\partial y_{1}}{\partial x_{1}} &amp; \frac{\partial y_{1}}{\partial x_{2}} &amp; \cdots &amp; \frac{\partial y_{1}}{\partial x_{n}}  \\<br>\frac{\partial y_{2}}{\partial x_{1}} &amp; \frac{\partial y_{2}}{\partial x_{2}} &amp; \cdots &amp; \frac{\partial y_{2}}{\partial x_{n}}  \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>\frac{\partial y_{m}}{\partial x_{1}} &amp; \frac{\partial y_{m}}{\partial x_{2}} &amp; \cdots &amp; \frac{\partial y_{m}}{\partial x_{n}}<br>\end{matrix}<br>\right)<br>$$</p><p>上边这个按分子布局求得的向量对向量的求导结果，一般叫做<strong>雅克比 (Jacobian) 矩阵</strong>，有的资料又表示为 $\frac{\partial \mathbf{y}}{\partial \mathbf{x}^{T}}$。</p><p>如果按分母布局，则结果为 $n\times m$ 的矩阵：</p><p>$$<br>\frac{\partial \mathbf{y}}{\partial \mathbf{x}}<br>=<br>\left(<br>\begin{matrix}<br>\frac{\partial y_{1}}{\partial x_{1}} &amp; \frac{\partial y_{2}}{\partial x_{1}} &amp; \cdots &amp; \frac{\partial y_{m}}{\partial x_{1}}  \\<br>\frac{\partial y_{1}}{\partial x_{2}} &amp; \frac{\partial y_{2}}{\partial x_{2}} &amp; \cdots &amp; \frac{\partial y_{m}}{\partial x_{2}}  \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>\frac{\partial y_{1}}{\partial x_{n}} &amp; \frac{\partial y_{2}}{\partial x_{n}} &amp; \cdots &amp; \frac{\partial y_{m}}{\partial x_{n}}<br>\end{matrix}<br>\right)<br>$$</p><p>上边这个按分子布局求得的向量对向量的求导结果，一般叫做<strong>梯度矩阵</strong>，有的资料又表示为 $\frac{\partial \mathbf{y}^{T}}{\partial \mathbf{x}}$。</p><p>观察上面两个矩阵，我们可以发现，分子布局的结果矩阵，保留了原分子向量的维度，即结果矩阵的每一列都是 $y_{1}$ 至 $y_{m}$，行数仍为 $m$；分母布局保留了原分母向量的维度，即结果矩阵的每一列都是 $x_{1}$ 至 $x_{n}$，行数为 $n$。</p><p>显然，<strong>对于某一种求导类型，不能同时使用分子布局和分母布局求导。</strong></p><p>在机器学习中，我们使用的是<strong>混合布局</strong>的思路。如果是向量或矩阵对标量求导，则使用分子布局；如果是标量对向量、矩阵求导，则以分母布局为准；而向量对向量求导，有些分歧，本文以分子布局的雅可比矩阵为主。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><table><thead><tr><th align="center">自变量\因变量</th><th>标量 $y$</th><th>列向量 $\mathbf{y}$</th><th>矩阵 $\mathbf{Y}$</th></tr></thead><tbody><tr><td align="center">标量 $x$</td><td>$\frac{\partial y}{\partial x}$</td><td><strong>分子布局：</strong>$m$ 维列向量<br>分母布局：$m$ 维行向量</td><td><strong>分子布局：</strong>$m\times n$<br>分母布局：$n\times m$</td></tr><tr><td align="center">列向量 $\mathbf{x}$</td><td>分子布局：$n$ 维行向量<br><strong>分母布局：</strong>$n$ 维列向量</td><td><strong>分子布局：</strong>$m\times n$ 雅可比矩阵<br>分母布局：$n\times m$ 梯度矩阵</td><td></td></tr><tr><td align="center">矩阵 $\mathbf{X}$</td><td>分子布局：$n\times m$<br><strong>分母布局：</strong>$m\times n$</td><td></td><td></td></tr></tbody></table><h2 id="定义法求导"><a href="#定义法求导" class="headerlink" title="定义法求导"></a>定义法求导</h2><h3 id="标量对向量求导"><a href="#标量对向量求导" class="headerlink" title="标量对向量求导"></a>标量对向量求导</h3><p>标量对向量求导，严格来说是实值函数对向量求导。即定义实值函数 $f:R^{n}\rightarrow R$，自变量 $\mathbf{x}$ 是 $n$ 维向量，输出值 $y$ 是标量。</p><p>前面我们也说过，标量对向量求导，实际上就是<strong>对向量的每个分量分别求导</strong>，再把结果排列在一起。那么我们可以将实值函数对向量的每一个分量求导，找到规律，得到结果向量。</p><p>举个简单的例子：$y=\mathbf{a}^{T}\mathbf{x}$，求解 $\frac{\partial\mathbf{a}^{T}\mathbf{x}}{\partial\mathbf{x}}$</p><p>根据定义，对 $\mathbf{x}$ 的第 $i$ 个分量求导：</p><p>$$<br>\frac{\partial \mathbf{a}^{T} \mathbf{x}}{\partial x_{i}}<br>=<br>\frac{\partial \sum_{j=1}^{n} a_{j} x_{j}}{\partial x_{i}}<br>=<br>\frac{\partial a_{i} x_{i}}{\partial x_{i}}<br>=<br>a_{i}<br>$$</p><p>可见，对向量的第 $i$ 个分量的求导结果等于向量 $\mathbf{a}$ 的第 $i$ 个分量。采用分母布局，最后得到的求导结果为 $\mathbf{a}$。即：</p><p>$$<br>\frac{\partial \mathbf{a}^{T} \mathbf{x}}{\partial \mathbf{x}}<br>=<br>\mathbf{a}\tag{1}<br>$$</p><p>同样使用定义法，我们可以得到</p><p>$$<br>\frac{\partial \mathbf{x}^{T} \mathbf{a}}{\partial \mathbf{x}}<br>=<br>\mathbf{a},<br>\frac{\partial \mathbf{x}^{T} \mathbf{x}}{\partial \mathbf{x}}<br>=<br>2\mathbf{x}\tag{2}<br>$$</p><p>再来看一个复杂点的例子：$y=\mathbf{x}^{T}\mathbf{A}\mathbf{x}$，求解 $\frac{\partial \mathbf{x}^{T} \mathbf{A} \mathbf{x}}{\partial \mathbf{x}}$</p><blockquote><p>不难推断矩阵 $\mathbf{A}$ 是方阵</p></blockquote><p>对 $\mathbf{x}$ 的第 $k$ 个分量进行求导如下：</p><p>$$<br>\frac{\partial \mathbf{x^{T}Ax}}{\partial x_{k}}<br>=<br>\frac{\partial \sum_{i=1}^{n} \sum_{j=1}^{n} x_{i}A_{ij}x_{j}}{\partial x_{k}}<br>=<br>\sum_{i=1}^{n}A_{ik}x_{i}<br>+<br>\sum_{j=1}^{n}A_{kj}x_{j}<br>$$</p><p>将这 $k$ 个分量组成向量，结果可表示为</p><p>$$<br>\frac{\partial \mathbf{x}^{T} \mathbf{A} \mathbf{x}}{\partial \mathbf{x}}<br>=<br>\mathbf{A}^{T}\mathbf{x}<br>+<br>\mathbf{Ax}\tag{3}<br>$$</p><h3 id="标量对向量求导的一些基本法则"><a href="#标量对向量求导的一些基本法则" class="headerlink" title="标量对向量求导的一些基本法则"></a>标量对向量求导的一些基本法则</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://en.wikipedia.org/wiki/Matrix_calculus">[1] Matrix Calculus - Wikipedia</a></p><p><a href="https://fei-wang.github.io/matrix.html">[2] 矩阵求导 - 蒙奇 D 路飞</a></p><p><a href="https://www.cnblogs.com/pinard/p/10750718.html">[3] 机器学习中的矩阵向量求导 - 刘建平Pinard</a></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity 使用 bvh 驱动骨骼动作</title>
    <link href="/2021/07/15/unity/unity-bvh/"/>
    <url>/2021/07/15/unity/unity-bvh/</url>
    
    <content type="html"><![CDATA[<p>本篇主要介绍如何在 Unity 中使用 bvh 驱动骨骼动画，同时从理论与实操两个方面进行阐述。</p><blockquote><p>代码已打包成 unitypackage，见链接 <a href="https://github.com/ZewanHuang/unitypackages/tree/master/3_BVHParser">BVHParser</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>先简单介绍一些相关的理论基础。</p><h3 id="BVH"><a href="#BVH" class="headerlink" title="BVH"></a>BVH</h3><p>BVH 文件是使用设备对人体运动进行捕获后产生的文件，它包含<strong>角色的骨骼和肢体关节旋转数据</strong>，是一种通用的人体特征动画文件格式。</p><p><img src="/img/articles/21-7-15/bvh.jpg" alt="图源于百度百科"></p><p>上图是 bvh 最常记录的骨骼点，图用节点表示关节，连线表示躯干，身体的各个部分形成子树的形式。</p><p>BVH 文件的第一部分定义了关节树、每个关节点的名称、关节与关节之间的相对位置（<strong>偏移量</strong>），即基本骨架。Hips 关节点作为整个人体的根节点，拥有三维空间位置参数，从而完成了对人体运动情况的完整描述。</p><p>BVH 文件的第二部分记录了运动的数据，定义了动作数据持续的长度（<strong>帧数</strong>）以及每帧之间的<strong>时间间隔</strong>。且按照第一部分定义的关节顺序提供每帧数据，记录了每一帧中各个关节点的位置信息和旋转信息（<strong>局部旋转量</strong>）。</p><p>BVH 文件示例见 <a href="https://raw.githubusercontent.com/ZewanHuang/BVHParser/master/Assets/Resources/bvh/13_29.bvh">Example.bvh</a></p><h3 id="角色姿势"><a href="#角色姿势" class="headerlink" title="角色姿势"></a>角色姿势</h3><p>一般来说，角色模型或 BVH 都有它的<strong>内置姿势</strong>，即创建模型时所设定的姿势。将一个模型<strong>所有关节的局部旋转量设置为单位四元数</strong>，则可显示出其内置姿势。</p><p>在对角色模型或 BVH 的处理中，通常涉及到三种姿势：A 型姿势(A-Pose)、<strong>T 型姿势</strong>(T-Pose)和其它姿势，其中 A-Pose 和 T-Pose 通常作为内置姿势或第一帧骨骼姿势。</p><p><img src="/img/articles/21-7-15/tpose.jpg" alt="T-Pose"></p><p><img src="/img/articles/21-7-15/apose.jpg" alt="A-Pose"></p><h2 id="驱动理论"><a href="#驱动理论" class="headerlink" title="驱动理论"></a>驱动理论</h2><p>了解了一些基础理论，接下来就来介绍一下 bvh 驱动的基本原理。</p><p>由于 bvh 的骨架与 unity 所使用和展示的骨架差异较大，因此仅赋值是无法实现需求的。但不管是 bvh 还是 unity 骨架，大多数都是基于 Tpose 的，且不同骨架的 Tpose 姿势一致，因此我们利用 Tpose 作为媒介，将 bvh 中的所有动画帧迁移至 unity 中。</p><p>接下来的推证，前提是 <strong>bvh 的第一帧是 Tpose</strong>。</p><h3 id="转换流程"><a href="#转换流程" class="headerlink" title="转换流程"></a>转换流程</h3><p><img src="/img/articles/21-7-15/flow.jpg" alt="转换流程图"></p><p>理解一下这个图。起初我们所拿到的数据是，Unity 模型的骨骼点信息和 BVH 每一帧动画关节点的局部旋转量；要实现的是，求出图中矩阵 $T_{5}$，应用到 <strong>Unity 每个关节的旋转量</strong>上，使 Unity 模型展示出相应动作。</p><p>事实上，将该图命名为流程图不太合适，可以理解成 $T_{5}$ 的<strong>求解过程</strong>吧。</p><p>先看 BVH。将 BVH 某一帧的所有关节点旋转量乘上矩阵 $T_{2}$，变换成 Tpose，再乘上 $T_{4}$，变化为相应动画。之所以这样做，是为了拿出 <strong>Tpose</strong> 这个中间媒介。Unity 和 BVH 骨架的 Tpose 姿势一致，想要展示的动作也一致，因此 $T_{4}$ 作用于 Unity 的 Tpose上，可以在 Unity 模型上展示出动作。</p><p>这样的话，求解 $T_{5}$ 仅需再求出 $T_{1}$ 即可实现，我们下面具体介绍一下求解原理。</p><h3 id="矩阵求解"><a href="#矩阵求解" class="headerlink" title="矩阵求解"></a>矩阵求解</h3><h4 id="变换矩阵-T-1-T-2"><a href="#变换矩阵-T-1-T-2" class="headerlink" title="变换矩阵 $T_{1}$/$T_{2}$"></a>变换矩阵 $T_{1}$/$T_{2}$</h4><p>通常而言，CMU 等提供的 BVH 动画，第一帧通常就是 Tpose，Unity 导入模型后通常也是 T 型姿势，因此无需复杂的转换。</p><p>但需要注意，我们所获得的数据信息，是骨骼节点相对于父节点的局部旋转量，需要使用下面公式将其转换为全局旋转矩阵 (Rotation)。</p><p>$$<br>R_{i}=R_{p}\times r_{i}<br>$$</p><p>其中，$R_{i}$ 为所求的当前节点的全局旋转（四元数），$R_{p}$ 为父节点的全局旋转，$r_{i}$ 为当前节点的局部旋转。</p><p>使用上式将 Unity 模型和 BVH <strong>第一帧</strong>的局部旋转转化为全局旋转，则得到了矩阵 $T_{1}$、$T_{2}$。</p><h4 id="变换矩阵-T-3"><a href="#变换矩阵-T-3" class="headerlink" title="变换矩阵 $T_{3}$"></a>变换矩阵 $T_{3}$</h4><p>BVH 中记录了完整的动画数据，我们可以根据它们计算出每一帧所有关节的坐标位置 (Position)。</p><p>在 BVH 中，根节点比其它节点多了个位置信息，根据根节点的位置信息 Root Position、关节层次关系 Hierachy、各节点相对父节点的偏移量 Offset (BVH 初始姿势)和每一帧节点旋转量，就可以推算出所有关节的坐标位置：</p><p>$$<br>Pos_{i} = Pos_{p} + R_{p} \times Offset_{i}<br>$$</p><p>其中，$Pos_{i}$ 为当前关节点坐标，$Pos_{p}$ 为父节点坐标，$R_{p}$ 为父节点全局旋转，$Offset_{i}$ 为当前节点相对父节点的偏移量 (Vector3)。</p><h4 id="变换矩阵-T-4"><a href="#变换矩阵-T-4" class="headerlink" title="变换矩阵 $T_{4}$"></a>变换矩阵 $T_{4}$</h4><p>前面我们说过，$T_{4}$ 是迁移的关键矩阵，计算出它，我们就能计算出 $T_{5}$。</p><p>观察流程图，我们可以推出：</p><p>$$<br>T_{2}\times T_{4} = T_{3}<br>$$</p><p>则</p><p>$$<br>T_{4} = T_{2}^{-1} \times T_{3}<br>$$</p><h4 id="变换矩阵-T-5"><a href="#变换矩阵-T-5" class="headerlink" title="变换矩阵 $T_{5}$"></a>变换矩阵 $T_{5}$</h4><p>Tpose 姿势一致，动画效果一致，因此 $T_{4}$ 可作用于 Unity 的 Tpose 上。故我们可求出 $T_{5}$：</p><p>$$<br>T_{5} = T_{1} \times T_{4} = T_{1} \times T_{2}^{-1} \times T_{3}<br>$$</p><h3 id="位置调整"><a href="#位置调整" class="headerlink" title="位置调整"></a>位置调整</h3><p>上述矩阵都是作用于各关节点的旋转量上的，但动画除此之外还有<strong>根节点的位置</strong>，通过调整它来调整人物的位置。</p><p>因此 BVH 的人物大小和 Unity 模型大小不同，所以我们通常根据某根骨骼的长度计算缩放比例，然后对 BVH 的根节点位置乘以缩放比例，就得到 Unity 根节点的位置了。</p><p>$$<br>Pos_{r}^{(unity)} = Pos_{r}^{(bvh)} \times Scale<br>$$</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>前面讲解了 BVH 驱动相关原理，接下来大致讲述一下核心代码实现。项目代码见 <a href="https://github.com/ZewanHuang/BVHParser">BVHParser</a>。</p><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><p><strong>获取关节父子关系</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> Dictionary&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">getHierachy</span>(<span class="hljs-params"></span>)</span><br>&#123;<br>    Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; hierachy = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;();<br>    <span class="hljs-keyword">foreach</span> (BVHBone bb <span class="hljs-keyword">in</span> boneList)<br>    &#123;<br>        <span class="hljs-keyword">foreach</span> (BVHBone bbc <span class="hljs-keyword">in</span> bb.children)<br>        &#123;<br>            hierachy.Add(bbc.name, bb.name);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> hierachy;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>欧拉角转四元数</strong></p><p>注意所用的 bvh 数据是否是 <code>ZYX</code> 顺序，若不是，需要根据 bvh 的顺序修改函数参数顺序。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> Quaternion <span class="hljs-title">eul2quat</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> z, <span class="hljs-built_in">float</span> y, <span class="hljs-built_in">float</span> x</span>)</span><br>&#123;<br>    z = z * Mathf.Deg2Rad;<br>    y = y * Mathf.Deg2Rad;<br>    x = x * Mathf.Deg2Rad;<br><br>    <span class="hljs-comment">// 动捕数据是ZYX，但是unity是ZXY</span><br>    <span class="hljs-built_in">float</span>[] c = <span class="hljs-keyword">new</span> <span class="hljs-built_in">float</span>[<span class="hljs-number">3</span>];<br>    <span class="hljs-built_in">float</span>[] s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">float</span>[<span class="hljs-number">3</span>];<br>    c[<span class="hljs-number">0</span>] = Mathf.Cos(x / <span class="hljs-number">2.0f</span>); c[<span class="hljs-number">1</span>] = Mathf.Cos(y / <span class="hljs-number">2.0f</span>); c[<span class="hljs-number">2</span>] = Mathf.Cos(z / <span class="hljs-number">2.0f</span>);<br>    s[<span class="hljs-number">0</span>] = Mathf.Sin(x / <span class="hljs-number">2.0f</span>); s[<span class="hljs-number">1</span>] = Mathf.Sin(y / <span class="hljs-number">2.0f</span>); s[<span class="hljs-number">2</span>] = Mathf.Sin(z / <span class="hljs-number">2.0f</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Quaternion(<br>        c[<span class="hljs-number">0</span>] * c[<span class="hljs-number">1</span>] * s[<span class="hljs-number">2</span>] - s[<span class="hljs-number">0</span>] * s[<span class="hljs-number">1</span>] * c[<span class="hljs-number">2</span>],<br>        c[<span class="hljs-number">0</span>] * s[<span class="hljs-number">1</span>] * c[<span class="hljs-number">2</span>] + s[<span class="hljs-number">0</span>] * c[<span class="hljs-number">1</span>] * s[<span class="hljs-number">2</span>],<br>        s[<span class="hljs-number">0</span>] * c[<span class="hljs-number">1</span>] * c[<span class="hljs-number">2</span>] - c[<span class="hljs-number">0</span>] * s[<span class="hljs-number">1</span>] * s[<span class="hljs-number">2</span>],<br>        c[<span class="hljs-number">0</span>] * c[<span class="hljs-number">1</span>] * c[<span class="hljs-number">2</span>] + s[<span class="hljs-number">0</span>] * s[<span class="hljs-number">1</span>] * s[<span class="hljs-number">2</span>]<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>获取关键帧的全局旋转数据</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> Dictionary&lt;<span class="hljs-built_in">string</span>,Quaternion&gt; <span class="hljs-title">getKeyFrame</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> frameIdx</span>)</span><br>&#123;<br>    Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; hierachy = getHierachy();<br>    Dictionary&lt;<span class="hljs-built_in">string</span>, Quaternion&gt; boneData = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, Quaternion&gt;();<br>    boneData.Add(<span class="hljs-string">&quot;pos&quot;</span>, <span class="hljs-keyword">new</span> Quaternion(<br>        boneList[<span class="hljs-number">0</span>].channels[<span class="hljs-number">0</span>].values[frameIdx],<br>        boneList[<span class="hljs-number">0</span>].channels[<span class="hljs-number">1</span>].values[frameIdx],<br>        boneList[<span class="hljs-number">0</span>].channels[<span class="hljs-number">2</span>].values[frameIdx],<span class="hljs-number">0</span>));<br><br>    boneData.Add(boneList[<span class="hljs-number">0</span>].name, eul2quat(<br>        boneList[<span class="hljs-number">0</span>].channels[<span class="hljs-number">3</span>].values[frameIdx],<br>        boneList[<span class="hljs-number">0</span>].channels[<span class="hljs-number">4</span>].values[frameIdx],<br>        boneList[<span class="hljs-number">0</span>].channels[<span class="hljs-number">5</span>].values[frameIdx]));<br>    <span class="hljs-keyword">foreach</span> (BVHBone bb <span class="hljs-keyword">in</span> boneList)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (bb.name != boneList[<span class="hljs-number">0</span>].name)<br>        &#123;<br>            Quaternion localrot = eul2quat(bb.channels[<span class="hljs-number">3</span>].values[frameIdx],<br>                                           bb.channels[<span class="hljs-number">4</span>].values[frameIdx],<br>                                           bb.channels[<span class="hljs-number">5</span>].values[frameIdx]);<br>            boneData.Add(bb.name, boneData[hierachy[bb.name]] * localrot);<br>        &#125;                <br>    &#125;            <br>    <span class="hljs-keyword">return</span> boneData;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>获取 BVH 初始姿势每个关节相对于父关节的偏移量</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> Dictionary&lt;<span class="hljs-built_in">string</span>,Vector3&gt; <span class="hljs-title">getOffset</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> ratio</span>)</span> &#123;<br>    Dictionary&lt;<span class="hljs-built_in">string</span>, Vector3&gt; offset = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, Vector3&gt;();<br>    <span class="hljs-keyword">foreach</span>(BVHBone bb <span class="hljs-keyword">in</span> boneList)<br>    &#123;<br>        offset.Add(bb.name, <span class="hljs-keyword">new</span> Vector3(bb.offsetX * ratio, bb.offsetY * ratio, bb.offsetZ * ratio));<br>    &#125;<br>    <span class="hljs-keyword">return</span> offset;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>获取 BVH 的全局旋转，即 $T_{2}$</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Csharp">bvhT = bp.getKeyFrame(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p><strong>计算 $T_{5}$</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Csharp"><span class="hljs-keyword">foreach</span> (BoneMap bm <span class="hljs-keyword">in</span> bonemaps)<br>&#123;<br>    Transform currBone = anim.GetBoneTransform(bm.humanoid_bone);<br>    currBone.rotation = (currFrame[bm.bvh_name] * Quaternion.Inverse(bvhT[bm.bvh_name])) * unityT[bm.humanoid_bone];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>确保 bvh 动捕数据第一帧为 Tpose</li><li>运行时 Scene 界面用红线画出了 bvh 动作骨架，可用以鉴别 bvh 动作是否导入成功</li><li>若使用的 bvh 文件的旋转量不是 ZYX 顺序，请相应修改 BVHParser.cs 中的 eul2quat 函数，一般只需调换该函数参数顺序即可</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文先简要介绍了几个基础知识 BVH 和角色姿势，后阐述了 BVH 驱动动作生成的理论（以 Tpose 为中间媒介求解转换矩阵），并使用代码实现。</p><p>项目地址见 <a href="https://github.com/ZewanHuang/unitypackages/tree/master/3_BVHParser">BVHParser</a>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/zb1165048017/article/details/112394097">[1] Unity 中 BVH 骨骼动画驱动的可视化理论与实现 - CSDN</a></p><p><a href="https://baike.baidu.com/item/bvh/3691673">[2] BVH - 百度百科</a></p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>bvh</tag>
      
      <tag>3D动画</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器部署 Nginx + Django + Vue</title>
    <link href="/2021/06/24/deploy/deploy-django-vue/"/>
    <url>/2021/06/24/deploy/deploy-django-vue/</url>
    
    <content type="html"><![CDATA[<p>本篇记录我配置和部署服务器的每一步，主要包括服务器配置 Django 虚拟环境、uWSGI 和 Nginx 的使用以及报错的纠正。以 Linux 服务器为例，因此需要具备一定的 Linux 知识基础。</p><h2 id="服务器预设"><a href="#服务器预设" class="headerlink" title="服务器预设"></a>服务器预设</h2><h3 id="租服务器"><a href="#租服务器" class="headerlink" title="租服务器"></a>租服务器</h3><p>各大云平台，如腾讯云、阿里云、华为云等，都有学生优惠。我这里选择的是腾讯云，原因：控制台界面简洁优雅。</p><p>相关配置仅供参考：</p><p><img src="/img/articles/21-6-24/server.png" alt="服务器配置"></p><ul><li>镜像信息：CentOS 7.6 64bit</li><li>实例规格：CPU 1核，内存 2GB</li><li>磁盘：系统盘 40GB</li><li>流量包套餐：带宽 5Mbps，流量包 1000GB/月（免费）</li></ul><h3 id="SSH-远程连接"><a href="#SSH-远程连接" class="headerlink" title="SSH 远程连接"></a>SSH 远程连接</h3><p>配置 SSH 远程连接，方便本地操作服务器，而无需每次都登录云平台。</p><p>在控制台中点击登录，进入服务器终端。第一步需要初始化超级用户 root 的密码，进入 superuser 权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo passwd       <span class="hljs-comment"># 初始化密码</span><br>su                <span class="hljs-comment"># 切换到root超级用户</span><br></code></pre></td></tr></table></figure><p>修改配置文件，允许密码或密钥远程连接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/ssh/sshd_config      <span class="hljs-comment"># 编辑ssh设置文件</span><br></code></pre></td></tr></table></figure><p>在打开的文件中，修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">RSAAuthentication yes                       <span class="hljs-comment"># 开启rsa验证，需要添加</span><br>PubkeyAuthentication yes                    <span class="hljs-comment"># 开启公钥登录，一般被注释掉了，去掉前面的#就好</span><br>AuthorizedKeysFile .ssh/authorized_keys     <span class="hljs-comment"># 公钥保存位置，原来就有</span><br>PasswordAuthentication yes                  <span class="hljs-comment"># 开启使用密码登录</span><br></code></pre></td></tr></table></figure><p>保存退出，重启 SSH 服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">service sshd restart        <span class="hljs-comment"># 重启ssh服务</span><br></code></pre></td></tr></table></figure><p>设置完毕后，即可在本地 powershell 或 git bash 连接服务器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh root@&lt;IP address&gt;       <span class="hljs-comment"># IP address 为你服务器的公网IP地址</span><br></code></pre></td></tr></table></figure><p>另外，VScode 的 <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-ssh">Remote - SSH</a> 远程连接插件真香。</p><h3 id="配置公钥"><a href="#配置公钥" class="headerlink" title="配置公钥"></a>配置公钥</h3><p>配置公钥后，本地连接服务器，无需每次都输入密码。</p><p>首先，生成本地电脑的公钥。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa           <span class="hljs-comment"># 打开cmd或powershell输入</span><br></code></pre></td></tr></table></figure><p>默认回车即可，成功后在 <code>C:\Users\用户名\.ssh</code> 文件夹下会生成 <code>id_rsa</code> 和 <code>id_rsa.pub</code>，后者就是本地用户的密钥。打开该文件，复制内容。然后使用 ssh 命令登录远程服务器，在 root 用户根目录下创建 .ssh 文件夹并进入，再创建 authorized_keys 文件，将密钥粘贴进去，之后重启 ssh 服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">service sshd restart        <span class="hljs-comment"># 重启ssh</span><br></code></pre></td></tr></table></figure><h3 id="更新系统软件包"><a href="#更新系统软件包" class="headerlink" title="更新系统软件包"></a>更新系统软件包</h3><p>服务器的预配置都比较古老，依次输入以下命令升级软件包或依赖。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum update -y                               <span class="hljs-comment"># 更新系统软件包</span><br>yum -y groupinstall <span class="hljs-string">&quot;Development tools&quot;</span>     <span class="hljs-comment"># 安装软件管理包</span><br>yum install openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlite-devel psmisc libffi-devel epel-release     <span class="hljs-comment"># 安装可能使用的依赖</span><br></code></pre></td></tr></table></figure><h2 id="配置-Django"><a href="#配置-Django" class="headerlink" title="配置 Django"></a>配置 Django</h2><h3 id="安装-python3-8-4"><a href="#安装-python3-8-4" class="headerlink" title="安装 python3.8.4"></a>安装 python3.8.4</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>                   <span class="hljs-comment"># 我一般喜欢把文件下载到该目录下</span><br>wget https://www.python.org/ftp/python/3.8.4/Python-3.8.4.tgz<br>tar -zxvf Python-3.8.4.tgz      <span class="hljs-comment"># 解压python包</span><br></code></pre></td></tr></table></figure><p>进入 Python 包路径，并编译安装到指定路径 /usr/local/python3</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> Python-3.8.4<br>./configure --prefix=/usr/<span class="hljs-built_in">local</span>/python3<br>make &amp;&amp; make install<br></code></pre></td></tr></table></figure><p>安装成功后，建立软链接，添加环境变量。因为服务器系统自带有 python、python2、python3，因此我命名为 python3.8，避免冲突。但我的服务器只有 pip3 没有 pip，所以我将 pip3.8 的软连接命名为 pip。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ln -s /usr/<span class="hljs-built_in">local</span>/python3/bin/python3.8 /usr/bin/python3.8<br>ln -s /usr/<span class="hljs-built_in">local</span>/python3/bin/pip3.8 /usr/bin/pip<br></code></pre></td></tr></table></figure><p>检测是否安装成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3.8 -V<br>pip -V<br></code></pre></td></tr></table></figure><h3 id="安装虚拟环境"><a href="#安装虚拟环境" class="headerlink" title="安装虚拟环境"></a>安装虚拟环境</h3><p>建议安装虚拟环境 virtualenv，当不同项目要求的 python 版本不同时，不会产生冲突。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install virtualenv<br>pip install virtualenvwrapper       <span class="hljs-comment"># 管理虚拟环境</span><br></code></pre></td></tr></table></figure><p>下载成功后，创建存储虚拟环境的目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkdir ~/.virtualenvs                <span class="hljs-comment"># 我一般存放在 /root/.virtualenvs，可自行修改</span><br></code></pre></td></tr></table></figure><p>查找 <code>virtualenvwrapper.sh</code> 文件位置，添加环境。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name virtualenvwrapper.sh<br></code></pre></td></tr></table></figure><p>编辑 <code>.bash_profile</code> 文件，在末尾添加这两句，其中 <code>source</code> 后的路径为前面查到的路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> WORKON_HOME=<span class="hljs-variable">$HOME</span>/.virtualenvs<br><span class="hljs-built_in">source</span>  /usr/<span class="hljs-built_in">local</span>/python3/bin/virtualenvwrapper.sh<br></code></pre></td></tr></table></figure><p>保存修改后，更新配置信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bash_profile <br></code></pre></td></tr></table></figure><p>如果保存时报错，在 /etc/profile 中加入下面内容，再 <code>source</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3.8<br><span class="hljs-built_in">export</span> VIRTUALENVWRAPPER_VIRTUALENV=/usr/<span class="hljs-built_in">local</span>/python3/bin/virtualenv<br></code></pre></td></tr></table></figure><h3 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h3><p>通过 -p 指定使用的Python版本，创建成功后自动进入该虚拟环境。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkvirtualenv -p python3.8 django        <span class="hljs-comment"># django为虚拟环境名称</span><br></code></pre></td></tr></table></figure><p>如果你希望将当前虚拟环境安装的所有插件配置到新虚拟环境中，可以执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip freeze &gt; requirements.txt           <span class="hljs-comment"># 导出依赖</span><br>pip install -r requirements.txt         <span class="hljs-comment"># 进入新虚拟环境后再执行</span><br></code></pre></td></tr></table></figure><p><strong>虚拟环境的其它常用命令</strong></p><ul><li>查看创建的全部虚拟环境：<code>workon</code></li><li>使用某一虚拟环境：<code>workon 虚拟环境名称</code></li><li>退出当前虚拟环境：<code>deactivate</code></li><li>删除虚拟环境：<code>rmvirtualenv 虚拟环境名称</code> 记得退出再删除</li></ul><h3 id="虚拟环境中安装-Django-和-uWSGI"><a href="#虚拟环境中安装-Django-和-uWSGI" class="headerlink" title="虚拟环境中安装 Django 和 uWSGI"></a>虚拟环境中安装 Django 和 uWSGI</h3><p>uWSGI 可以理解为服务器上持续运行 Django 的代理服务器，用于与 Django 后端进行数据传输等，后续配置需要使用。</p><p>进入前面创建的虚拟环境，安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install django==3.2         <span class="hljs-comment"># 可指定版本</span><br>pip install uwsgi<br></code></pre></td></tr></table></figure><blockquote><p>uWSGI 要安装两次，一次在虚拟环境中，另一次退出虚拟环境进行安装</p></blockquote><p>创建 uWSGI 的软链接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ln -s /usr/<span class="hljs-built_in">local</span>/python3/bin/uwsgi /usr/bin/uwsgi<br></code></pre></td></tr></table></figure><h2 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h2><p>Nginx 是 Http 反向代理 web 服务器，同时也提供 IMAP/POP3/SMTP 服务，占用内存少，并发能力强。在这里我们只需要了解，Nginx 能帮我们在指定端口跑我们的项目就好了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install nginx<br></code></pre></td></tr></table></figure><p>安装成功后，相关的文件存储路径为</p><ul><li>安装成功后，默认的网站目录为 <code>/usr/share/nginx/html</code></li><li>默认的配置文件为 <code>/etc/nginx/nginx.conf</code></li><li>自定义配置文件目录为 <code>/etc/nginx/conf.d/</code></li></ul><p>在启动之前，还需确保服务器的相关端口已打开。http 对应 80 端口，https 对应 443 端口。一般在云平台租的服务器，可以在控制台中的防火墙处开启相应端口。我的设置可供参考。</p><p><img src="/img/articles/21-6-24/duankou.png" alt="服务器端口"></p><p>接下来启动 Nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start nginx<br></code></pre></td></tr></table></figure><p>启动成功后，浏览器搜索服务器 IP 地址，就能访问到 Nginx 主页了。</p><p><img src="/img/articles/21-6-24/Nginx.jpg" alt="Nginx 默认主页"></p><h2 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h2><h3 id="上传项目"><a href="#上传项目" class="headerlink" title="上传项目"></a>上传项目</h3><p>Django 后端项目文件，直接上传至服务器即可。Vue 框架写的前端，需要使用 <code>npm run build</code> 命令进行打包，再将生成的 dist 目录上传。</p><p>这里推荐软件 <a href="https://filezilla-project.org/">FileZilla</a>，用于本地与服务器文件传输十分方便。</p><h3 id="配置-uWSGI"><a href="#配置-uWSGI" class="headerlink" title="配置 uWSGI"></a>配置 uWSGI</h3><p>新建文件 uwsgi.ini，我习惯放置于 Django 项目的根目录下，用于指定项目路径、最大进程数、运行端口等。我的配置参数可供参考。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[uwsgi]</span><br><span class="hljs-attr">socket</span> = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8080</span><br><span class="hljs-attr">chdir</span> = /root/Ops/django<br><span class="hljs-attr">wsgi-file</span> = /root/Ops/django/django3/wsgi.py<br><span class="hljs-attr">master</span> = <span class="hljs-literal">true</span> <br><span class="hljs-attr">enable-threads</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">processes</span> = <span class="hljs-number">8</span><br><span class="hljs-attr">buffer-size</span> = <span class="hljs-number">65536</span><br><span class="hljs-attr">vacuum</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">daemonize</span> = /root/Ops/django/uwsgi.log<br><span class="hljs-attr">virtualenv</span> = /root/.virtualenvs/django<br><span class="hljs-attr">uwsgi_read_timeout</span> = <span class="hljs-number">600</span><br><span class="hljs-attr">threads</span> = <span class="hljs-number">4</span><br><span class="hljs-attr">chmod-socket</span> = <span class="hljs-number">664</span><br></code></pre></td></tr></table></figure><p>简要介绍该文件的配置信息：</p><ul><li><code>[uwsgi]</code>：必须有这个[uwsgi]，不然会报错</li><li><code>socket</code>：该端口为后端 Django 的运行端口，可自定义，但须与后面 Nginx 的配置一致</li><li><code>chdir</code>：django 项目路径</li><li><code>wsgi-file</code>：django 项目的 wsgi.py 文件路径</li><li><code>master</code>：开启主进程</li><li><code>processes</code>：最大进程数量</li><li><code>vacuum</code>：当服务器退出的时候自动删除 unix socket 文件和 pid 文件</li><li><code>daemonize</code>：输出日志，有报错时可查看</li><li><code>virtualenv</code>：项目虚拟环境路径</li></ul><p>切换当前路径到 uwsgi.ini 文件所在目录，启动 uWSGI。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">uwsgi --ini uwsgi.ini<br></code></pre></td></tr></table></figure><p>使用 <code>ps</code> 命令查看进程，检测是否成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -aux | grep uwsgi<br></code></pre></td></tr></table></figure><p><img src="/img/articles/21-6-24/uwsgi.png" alt="uwsgi 进程查看"></p><h3 id="配置-Nginx"><a href="#配置-Nginx" class="headerlink" title="配置 Nginx"></a>配置 Nginx</h3><blockquote><p>此处先给出部署域名的样例，仅服务器 IP 以后再给出。</p></blockquote><p>首先，删除 <code>/etc/nginx/nginx.conf</code> 文件中 <code>server&#123;...&#125;</code> 部分的代码。当然，如果怕出错，也可先将原本的 nginx.conf 文件备份一下。</p><p>接下来，在 <code>/etc/nginx/conf.d</code> 文件夹中修改默认文件 <code>default.conf</code>（若不存在则新建一个），文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs conf">server &#123;<br>    listen 80;<br>    listen 443 ssl;<br>    server_name  zewan.top www.zewan.top;<br><br>    location / &#123;<br>        root /root/Ops/vue/dist;<br>        index index.html index.htm;<br>        try_files $uri $uri/ /index.html;<br>    &#125;<br><br>    location /api &#123;        <br>        include /etc/nginx/uwsgi_params;<br>        uwsgi_pass 127.0.0.1:8080;                                                               <br>    &#125;<br><br>    ssl_certificate /etc/nginx/ssl/zewan.top.crt;<br>    ssl_certificate_key /etc/nginx/ssl/zewan.top.key;<br>    ssl_session_timeout  5m;<br>    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;<br>    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4:!DH:!DHE;<br>    ssl_prefer_server_ciphers  on;<br><br>    error_page 497  https://$host$uri?$args;<br>&#125;<br></code></pre></td></tr></table></figure><p>简要说明文件内容的作用：</p><ul><li><code>listen</code> 后接端口，即设定访问的端口，此处同时开放 80 和 443</li><li><code>server_name</code> 为访问域名</li><li><code>location /</code> 后描述前端 dist 项目文件夹的存放地址，<strong>需根据自身情况修改</strong>，注意 dist 即为前端项目的根目录</li><li><code>location /api</code> 后为后端项目运行端口，注意 <code>uwsgi_pass</code> 后须与之前 uWSGI 的配置保持一致</li><li><code>ssl_certificate[_key]</code> 为 SSL 证书存储路径</li></ul><p><strong>重要提醒</strong></p><p>采用 <code>location /api</code> 与 uWSGI 连接，最终将后端运行在 <code>:443/api/</code>。需保证后端的路由都是 <code>api/*</code>，即 Django 项目的 <code>urls.py</code> 文件所有路由前需加 <code>api/</code>。</p><h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><p>检测 Nginx 配置是否有误，成功后重启 Nginx 服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nginx -t                <span class="hljs-comment"># 测试</span><br>nginx -s reload         <span class="hljs-comment"># 重新加载</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>，若修改了后端 Django 内容或其它内容，须重启 uWSGI 和 Nginx 服务，否则不生效！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -ef | grep uwsgi         <span class="hljs-comment"># 查看uWSGI进程</span><br>killall -9 uwsgi            <span class="hljs-comment"># 用kill方法把uwsgi进程杀死</span><br>uwsgi --ini uwsgi.ini       <span class="hljs-comment"># 重启uwsgi</span><br>nginx -s reload             <span class="hljs-comment"># nginx平滑重启</span><br></code></pre></td></tr></table></figure><p>另外，如果你的项目文件存放于 root 用户目录下，访问网站时可能出现 500 或 403 Forbidden 权限报错，此时需修改 <code>/etc/nginx/nginx.conf</code>，将文件首行的 <code>user nginx</code> 修改为 <code>user root</code>。</p><p>至此网站已部署完毕，欢迎访问<a href="https://zewan.top/">我的网站</a>。项目<a href="https://github.com/ZewanHuang/Online-Publish-Vue">网上出版系统</a>已开源，欢迎交流学习！</p>]]></content>
    
    
    <categories>
      
      <category>配置与部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/06/16/notes/hello-world/"/>
    <url>/2021/06/16/notes/hello-world/</url>
    
    <content type="html"><![CDATA[<p>给博客换了个主题 Hexo Fluid，体验极佳，顺便简略记录一下部署过程和 Hexo 的一些基本用法。</p><span id="more"></span><h2 id="关于-Hexo"><a href="#关于-Hexo" class="headerlink" title="关于 Hexo"></a>关于 Hexo</h2><blockquote><p>引自官方文档</p></blockquote><p><a href="https://hexo.io/" target="_blank">Hexo</a> 是一个快速建议的博客框架，可使用 <a href="https://daringfireball.net/projects/markdown/" target="_blank">Markdown</a> 编辑页面。</p><p><a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank">Fluid</a> 是本博客采用的主题，十分美观，建议入坑。</p><h2 id="部署过程"><a href="#部署过程" class="headerlink" title="部署过程"></a>部署过程</h2><h3 id="1-准备环境-node-和-git"><a href="#1-准备环境-node-和-git" class="headerlink" title="1. 准备环境 node 和 git"></a>1. 准备环境 node 和 git</h3><p>node 环境的配置可以参照：<a href="https://www.cnblogs.com/jianguo221/p/11487532.html" target="_blank">windows安装npm教程–nodejs</a></p><p>上面参考资料只需要看前半部分。Git 安装较简单，大概下载安装即成功。</p><h3 id="2-安装-Hexo"><a href="#2-安装-Hexo" class="headerlink" title="2. 安装 Hexo"></a>2. 安装 Hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>安装完成后，找个你想放置博客项目文件的地方，执行下面命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init MyBlog<br><span class="hljs-built_in">cd</span> MyBlog<br>npm install<br></code></pre></td></tr></table></figure><p>新建完成后，文件夹目录与功能如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── _config.yml     <span class="hljs-comment"># 网站的配置信息，您可以在此配置大部分的参数。 </span><br>├── package.json<br>├── scaffolds       <span class="hljs-comment"># 模版文件夹</span><br>├── <span class="hljs-built_in">source</span>          <span class="hljs-comment"># 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹</span><br>|   ├── _drafts     <span class="hljs-comment"># 草稿文件</span><br>|   └── _posts      <span class="hljs-comment"># 文章Markdowm文件 </span><br>└── themes          <span class="hljs-comment"># 主题文件夹</span><br></code></pre></td></tr></table></figure><h3 id="3-导入-fluid-主题"><a href="#3-导入-fluid-主题" class="headerlink" title="3. 导入 fluid 主题"></a>3. 导入 fluid 主题</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><p>然后在博客目录下创建 _config.fluid.yml，该文件为主题配置文件，具体配置参见 <a href="https://hexo.fluid-dev.com/docs/guide/">Configuration</a>。我的个人配置仅作参考：<a href="https://paste.ubuntu.com/p/bmNjKsWZW9/" target="_blank">ZewanBlog_config.fluid.yml</a></p><p>如下修改 Hexo 博客目录中的 _config.yml：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span>        <span class="hljs-comment"># 指定主题</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span>     <span class="hljs-comment"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure><p>运行 <code>hexo s</code> 命令，在本地浏览 <a href="http://localhost:4000/">http://localhost:4000</a> 可以预览效果。</p><h3 id="4-新建-GitHub-仓库"><a href="#4-新建-GitHub-仓库" class="headerlink" title="4. 新建 GitHub 仓库"></a>4. 新建 GitHub 仓库</h3><p>注意仓库名必须是 用户名.github.io</p><h3 id="5-部署到-GitHub"><a href="#5-部署到-GitHub" class="headerlink" title="5. 部署到 GitHub"></a>5. 部署到 GitHub</h3><p>在 _config.yml 配置文件中修改：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span><br>    <span class="hljs-attr">github:</span> <span class="hljs-string">https://github.com/ZewanHuang/ZewanHuang.github.io</span>  <span class="hljs-comment"># 修改自己的仓库</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><p>安装部署插件 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank">hexo-deployer-git</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>最后执行命令部署上传，以下 g 是 generate 缩写，d 是 deploy 缩写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean      <span class="hljs-comment"># 清除缓存文件和已生成的静态文件</span><br>hexo g -d       <span class="hljs-comment"># 部署上传</span><br></code></pre></td></tr></table></figure><h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><h3 id="创建关于页面"><a href="#创建关于页面" class="headerlink" title="创建关于页面"></a>创建关于页面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new page about     <span class="hljs-comment"># 创建关于页面</span><br></code></pre></td></tr></table></figure><h3 id="创建新页面"><a href="#创建新页面" class="headerlink" title="创建新页面"></a>创建新页面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new <span class="hljs-string">&#x27;article-title&#x27;</span>    <span class="hljs-comment"># 新建页面</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo s<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean                  <span class="hljs-comment"># 清除缓存</span><br>hexo g -d                   <span class="hljs-comment"># 部署上传</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
